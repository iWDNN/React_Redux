# React

1-1. 소프트웨어의 가장 큰 특징

- 변한다.
- 현실의 문제를 해결하는 솔루션, 항상 문제도 다르기에 소프트웨어도 항상 바뀐다.
- 변경 용이성
- 안전하게 변경할수 있을까

1-2. 강의의 핵심

- 변경용이성에 대한 해결책을 어떻게 냈는가 하는, React에 대한 강의

2-1. 문제점의 중심

- 웹 어플리케이션 개발에 있어 가장 많은 문제점, DOM (웹 앱이 핸들링 UI를 핸들링 하기위해 사용할수 밖에 없는) 애초에 웹앱개발을 위해 만들어진 구조가 아니기때문에 웹 페이지일 뿐, 웹 앱으로의 사용성은 나오기 힘듬 (ajax가 나오고 앱처럼 구현은 시작됨)
- 웹 앱으로 만들수록 DOM API는 더 큰 문제만 야기함
- HTML Collection 은 라이브 오브젝트 참조형, NodeList는 참조형이 아님 DOM API는 일관성이 없음, 브라우저에서 호환되는게 모두 달라서 크로스 브라우징이슈도 있음
- 규모는 커져도 복잡도는 낮은, 비슷한것 끼리 모아서 복잡도를 낮춰보자
- MVC패턴(모델-뷰-컨트롤러) 뷰:UI 컨트롤러 : 모델과 뷰 사이의 로직들을 관리하는 컨트롤러
- 클라이언트 앱같은 경우가 로직들이 많아지고 뷰들도 굉장히 많아지다 보니, mvc패턴은 서버의 모델과 종속성이 커서 서버가 바뀌면 클라이언트도 굉장히 많이 바뀌는 단점을 가지고 있어서 MVM(모델-뷰-뷰모델) 패턴이 나옴. 클라이언트 쪽에서 독립적 상태를 관리할 수있는 패턴
- 패턴같은것들이 나온 이유는 클라이언트 앱 규모가 커지지만 복잡도는 일정수준으로 유지하기 위한 시도들 중 하나다. 이게 모두 DOM API 자체 문제점을 개선시켜주지 않았지만, 가장 성공적인건 React가 있다고 생각한다.
- React는 DOM API를 쓰지 말자라는 컨셉으로 안착

3-1. 어떻게 만들것인가

- MVP, 최소 기능 제품, minimum viable product, 많은 기능을 담으면 그 가치의 선명도가 떨어지기 때문에 핵심적인 부분만 초기에 담는게 좋다.

3-2. React의 mvp

- DOM의 문제를 해결 하기 위한, 세 가지 컨셉
- 선언적 : 선언적인 코드를
- 효율적 : DOM과 인터렉션을 최소화 DOM의 모의 표현을 사용하여 DOM을 처리한다.
- 유연성 : 우리가 알고 있는 라이브러리나 혹은 프레임워크와 같이 사용 할 수 있다. 라이브러리라 불리는 이유 : 모든 문제를 해결해주기 위함이 아닌 ui만 해결해주고싶었던
- 초기버전을 보는게 많은 도움이 된다. 0.3.0

4-1. 가장 안전한 코드

- 기존의 코드 제거, 추가, 삭제 된다는 일들이 빈번하게 일어나서 추가와 변경만 두고 봤을때, 아예 안바꾸는, 안 바뀌는 곳과 바뀌는 부분을 두고 개발하는 방법 플러그인, 미들웨어
- 플러그인 : 크롬자체가 변경되지 않지만 크롬을 사용하여 확장프로그램을 사용하는, ex) 크롬의 웹스토어 확장 프로그램
- 미들웨어 : 운영체제와 응용 소프트웨어의 중간에서 조정과 중계의 역할을 수행하는 소프트웨어, 기존은 바뀌지 않지만 새로운 기능은 추가할 수 있는 환경인 컨셉 ex) express
- 컴포넌트 아키텍쳐 : 변경되지 않는 단단한 컴포넌트안에서 새로운것만 변경시키는 컨셉

5. 웹프론트엔드 개발환경

- 번들러 웹팩, 로더 바벨, 에디터 Vs code
- 웹팩도 변하는 부분과 변하지 않는 곳을 구분한 플러그인 구조를 가지고 있다. 플러그인, 로더 - babel

# React 만들기

1.

- DOM API를 이용해서 만들면 구조적으로 이해하기도 힘들고 단점이 많다. 효율적이지 않다.
- DOM을 쓰지 말고 버려보자, 개발자에게는 DOM이 없는것처럼 사용하게 하고, 리엑트 자체에서만 제어하게 만드는. 이런 식의 컨셉
- DOM 자체도 그런 컨셉, html 문자열을 객체로 바꿔주자 자유도가 너무 높아서, 쉬운 포맷을 위해
- DOM 객체를 간단한 객체로 바꾸고 다시 복잡한 DOM객체로 바꿔주자. 사용자에게는 편리하게 만들어주는 경험
- 복잡한 DOM을 간단한 객체로 그 단순한 객체를 입력값으로 복잡한 DOM을 만드는,

2. 개발환경

- 현대적인 구조 , 번들링과 로더, 빌드가 되는 구조

  - webpack-cli : webpack은 웹팩의 핵심 패키지이며 webpack-cli는 터미널에서 webpack 커맨드를 실행할 수 있게 해주는 커맨드라인 도구
  - webpack-dev-server : 개발 환경 서버
  - babel-loader : 트랜스파일러
  - @babel/core : 바벨의 핵심파일
  - @babbel/preset-env : 바벨 개발 프리셋
  - @bable/preset-react
  - html-webpack-plugin : html 파일을 만들고 템플릿화 해서 번들링때 사용할 수 있는 도구

- 번들링 파일 설정
  - webpack.config.js : webpack에 입력값으로 config 파일을 제공해 주는 역할(파일설정은 내부파일에 주석)
  ```json
  module.export = {
  mode: "development", // 모드
  entry: "./app.js", // 입력정보
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "bundle.js",
  }, // 출력정보
  devServer: {
    compress: true,
    port: 9999,
  },
  module: {
    rules: [
      {
        test: /\.js$/, // js파일로 끝나는 친구들만
        exclude: /node_modules/, // 노드 모듈 제외
        use: {
          loader: "babel-loader",
          options: {
            presets: ["@babel/preset-env", "@babel/preset-react"],
          },
        },
      },
    ],
  }, //
  plugins: [
    new HtmlWebpackPlugin({
      title: "webpack & babel",
      template: "index.html",
    }),
  ],
  };
  ```

// entry - module(트랜스파일) - plugin - output
// es6 이상 파일 - moudle es5 트랜스 파일러 - plugin 주석제거

```
- 스크립트에 webpack(번들링만), webpack serve(개발 서버로 확인하게 해주는)로 실행시킬수있다.
```

3. @jsx

- createElment로 만들었지만 함수 호출은 불편함을 느낄수밖에 없어서, 마크업 문법처럼 createELement를 태그형태로 바꿨다.
- 바벨의 플러그인 중에 하나인 @babel/preset-react 마크업은 아니지만 jsx파일의 마크업 문법을 리엑트 함수인 createElement를 사용한 형태로 변환해준다.

- DOM으로 변환될 간단한 객체를 만들기 위해, createElement라는 헬퍼 함수를 만들었는데 그걸 함수호출식으로 사용하면 사용자에게 불편한 형태로 받아들이는게 일반적이라, 편리함을 추구하기 위해 html의 마크업구조의 표현 방법을 개발한 것, 사용자가 큰 어려움 없이 마크업 구조로 만들게 되었다. DOM보다 훨씬 간단한 구조물을 만드는데 성공했다는 장점, 그것을 생성하는데에 있어서 객체 리터럴, createElement 같은 함수로 호출했을 때 ui구조도 파악하기도 힘들고 작성하기도 힘든 형태를 마크업형태로 구조도 파악하기 쉽고 작성도 쉬운 두 마리의 토끼를 모두 잡은 상황

4. 함수 컴포넌트

- 위의 기능 정도로 React의 장점은 html 마크업과 자바스크립트를 혼용해서 사용할수 있다 정도였다. 리엑트는 한단계 더 나아가 사용자 컴포넌트를 만들수 있는 기능을 제공한다.
  - 함수 컴포넌트
    - html 태그와 같은 것만으로 마크업하는 것과는 완전 다르게 ui조각을 자바스크립트에 모듈화하듯이 조직화 할 수 있다. 모듈화 한다는건 언제든 재활용이 가능하고 사용자가 이름을 붙여서 html태그와는 다르게 훨씬 더 의미가 명확한 형태로 ui를 만들 수 있는 장점이 생긴다. (가독성이 높다는 장점과 재활용성)
    - React.createElement에서 받는 태그가 문자열, html태그, 대문자로 시작하는 문자열 세가지로 나눠서, 대문자로 시작하면 함수로 받는 방식으로 jsx문법으로 리턴 값이라는 약속을 사용하며 함수 컴포넌트를 사용한다.(함수인지 문자열인지 구분할 방도가 없어서 문자열의 대문자로 들어오면 함수로 인식하는 간단한 약속)
  - 클래스 컴포넌트
    - 최초 dom에 마운트 되고 나면 컴포넌트가 삭제될때까지 계속 유지하면서 만들어진 인스턴스를 가지고 그 사이에서 렌더만 호출하는 방식(상태를 가지는게 강점이었다)

5. Virtual DOM

- 역할 : DOM을 직접적으로 제어하지 않고 DOM을 훨씬 더 쉬운 구조물로 UI를 만들고 개발할수 있도록 중간의 DOM 처리는 React한테 맡기고 개발자에게는 jsx마치 돔과 비슷한 컴포넌트 베이스의 개발 방식을 만들어줄 수 있게 만든 환경이 바로 Virtual DOM
- 변화된 부분만 업데이트 하는 리엑트의 강점
- 가상 돔의 강점, 돔을 비교하는게 아닌 객체 대 객체를 비교해서 다른점만 실제 리얼 돔에 반영할수 있었기 때문에 리엑트가 핫했던 이유

6. Hook

- 클래스 컴포넌트만 상태를 가지고 있던 함수, 함수 컴포넌트가 상태를 가지지 못하는 단점을 보완해줌
- 추측) createElement에서 생성되는 컴포넌트에 맞게 hook들의 배열로 각 컴포넌트의 상태를 업데이트한다.
- 일반함수 상태는 당연히 훅을 호출해도 호출을 받지 못한다.
- class component는 instance가 업데이트 될때 생성되는게 아닌 자체가 업데이트가 되는거기 때문에 hook의 호출 시점을 만들어낼수가 없다.(잘모름)

7. React side effect

- 장점 : virtual dom , dom을 만들고 dom을 컨트롤 하기위한 중간매게체로서의 자료유형을 만들고 그것을 다루게 했다는것, 변환기를 갈아끼움으로써 React Native로 만들어줄수도 있는 활용처가 굉장히 높다. RServer side rendering 구현하기 편함. React 컴포넌트 코드인데 실제로 브라우저에 Dom을 만드는게 아니라 UI를 만들어내고 그걸 브라우저에 서빙하는 구조, 버츄얼돔으로 문자열로 만들면 그게 결국 서버사이드렌더링이다. 그 문자열을 브라우저에 보내서 렌더링 하면되기때문이다. 다양한 플랫폼에 이식하기 좋은게 가장 큰 장점

- 단점 : 원래 컴포넌트라는 것은 어디에서도 재활용이 극대화될 수 있는 형태의 소프트웨어 아키텍쳐인데, React로 만든 컴포넌트가 그렇게 재활용성이 높은가 생각해보면 그렇게 높지는 않다. 제공하는 스펙이 너무 단순하기도 하고 다른 프로젝트에 이식하기는 힘들다.

# Redux

- 데이터를 전역 상태로 공유할 때 컴포넌트간 프롭스드릴링(뎁스가 깊어지기만 하고 컴포넌트 중계로만 사용하는 현상) 현상을 해결하기 위해서 나온 간편한 전역 상태 관리 라이브러리

- one way binding 상태 관리 기법(flux 아키텍쳐) : 데이터가 한 방향으로 흐르는 기법

  - 만들어진 이유 : 구글에서 나온 앵귤러라는 프레임워크가 two way binding이라는 기법을 가지고 나왔습니다. 데이터 즉 상태가 있을때 그 상태를 UI와 연결 해놓으면
    데이터와 ui가 서로 상호작용 하여 한쪽이 바뀌면 서로 바뀌어주는 형태를 제공했다. 하지만 데이터를 여러개와 연동했을때 상태도 많아지고 연결된 ui도 많아지면서 그게 어떤 ui와 연결됐는지 알수도없고 찾기도 힘들고 성능도 떨어져서 여러가지 문제들이 복합적으로 발생하였다.

  - data flow
    <img src="https://facebook.github.io/flux/img/overview/flux-simple-f8-diagram-with-client-action-1300w.png" />

  - flux 아키텍쳐의 초기모델은 번잡하고 불편하여 사용하지 않다가 flux 아키텍쳐를 깔끔하게 구현한 redux가 나오면서 주도적인 프레임워크가 됐다.
  - 완전히 동기적인 코드

- 미들웨어
  - redux가 제공하는 store의 action 무언가를 하기 위한 action을 던져주고 그 action에 맞춰서 상태가 업데이트 되는 이 흐름 안에서 작동할 수 있는 아키텍쳐를 마련해야겠다. 그래서 채용한 아키텍쳐가 미들웨어이다.

# 몰랐던 용어들

- cli : 커맨드라인 인터페이스(Command-line Interface, CLI)란 사용자가 텍스트로 명령어를 입력하고 다시 텍스트로 결과를 화면에 출력해주는 인터페이스를 가진 컴퓨팅 인터페이스를 의미합니다.
